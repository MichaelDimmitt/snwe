"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var eventemitter3_1 = require("eventemitter3");
var util_1 = require("./util");
/**
 * Implements the [general syntax](http://www.musicpd.org/doc/protocol/syntax.html)
 * of the [Music Player Daemon protocol](http://www.musicpd.org/doc/protocol/index.html)
 */
var MPDProtocol = (function (_super) {
    __extends(MPDProtocol, _super);
    function MPDProtocol() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ready = false;
        _this.idle = false;
        _this.runningRequests = [];
        _this.queuedRequests = [];
        _this.receivedLines = [];
        return _this;
    }
    Object.defineProperty(MPDProtocol.prototype, "isReady", {
        get: function () { return this.ready; },
        enumerable: true,
        configurable: true
    });
    /**
     * Connect to the daemon via the given connection
     */
    MPDProtocol.prototype.connect = function (connection) {
        var _this = this;
        if (this._connection) {
            throw new Error('Client is already connected');
        }
        this._connection = connection;
        return this._connection.connect(function (msg) { return _this.processReceivedMessage(msg); }, function (eventName, arg) { return _this.emit(eventName, arg); });
    };
    /**
     * Disconnect from the daemon
     */
    MPDProtocol.prototype.disconnect = function () {
        if (!this._connection) {
            throw new Error('Client isn\'t connected');
        }
        this.runningRequests.forEach(function (request) { return request.reject('Disconnected'); });
        this.queuedRequests.forEach(function (request) { return request.reject('Disconnected'); });
        this._connection.disconnect();
        this._connection = null;
        this.ready = false;
        this.idle = false;
        this.runningRequests = [];
        this.queuedRequests = [];
        this.receivedLines = [];
    };
    /**
     * Send a command to the daemon. The returned promise will be resolved with an array
     * containing the lines of the daemon's response.
     */
    MPDProtocol.prototype.sendCommand = function (cmd) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var mpdRequest = { cmd: cmd, resolve: resolve, reject: reject };
            _this.enqueueRequest(mpdRequest);
        });
    };
    /**
     * Helper function for parsing a response from the daemon into an array of objects
     * @param lines		The daemon response
     * @param markers	Markers are keys denoting the start of a new object within the response
     * @param convert	Converts a key-value Map from the response into the desired target object
     */
    MPDProtocol.prototype.parse = function (lines, markers, convert) {
        var result = new Array();
        var currentValueMap = new Map();
        var lineCount = 0;
        lines.forEach(function (line) {
            var colonIndex = line.indexOf(':');
            if (colonIndex > 0) {
                var key = line.substring(0, colonIndex);
                var value = line.substring(colonIndex + 2);
                if ((lineCount > 0) && markers.some(function (marker) { return (marker == key); })) {
                    result.push(convert(currentValueMap));
                    currentValueMap = new Map();
                }
                currentValueMap.set(key, value);
                lineCount++;
            }
        });
        if (lineCount > 0) {
            result.push(convert(currentValueMap));
        }
        return result;
    };
    MPDProtocol.prototype.enqueueRequest = function (mpdRequest) {
        this.queuedRequests.push(mpdRequest);
        if (this.idle) {
            this._connection.send('noidle\n');
            this.idle = false;
        }
    };
    MPDProtocol.prototype.processReceivedMessage = function (msg) {
        if (!this.ready) {
            this.initialCallback(msg.substring(0, msg.length - 1));
            this.ready = true;
            this.dequeueRequests();
            return;
        }
        if (this.receivedLines.length > 0) {
            var lastPreviousLine = this.receivedLines.pop();
            msg = lastPreviousLine + msg;
        }
        var lines = msg.split('\n');
        for (var i = 0; i < (lines.length - 1); i++) {
            var line = lines[i];
            if ((line == 'list_OK') || (line == 'OK')) {
                if (this.runningRequests.length > 0) {
                    var req = this.runningRequests.shift();
                    req.resolve(this.receivedLines);
                    this.receivedLines = [];
                }
            }
            else if (util_1.stringStartsWith(line, 'ACK [')) {
                if (this.runningRequests.length > 0) {
                    var req = this.runningRequests.shift();
                    var match = MPDProtocol.failureRegExp.exec(line);
                    if (match != null) {
                        var mpdError = { errorCode: Number(match[1]), errorMessage: match[2] };
                        req.reject(mpdError);
                        this.queuedRequests = this.runningRequests.concat(this.queuedRequests);
                        this.runningRequests = [];
                    }
                    this.receivedLines = [];
                }
            }
            else {
                this.receivedLines.push(line);
            }
        }
        this.receivedLines.push(lines[lines.length - 1]);
        if ((lines.length >= 2) && (lines[lines.length - 1] == '') &&
            ((lines[lines.length - 2] == 'OK') || util_1.stringStartsWith(lines[lines.length - 2], 'ACK ['))) {
            this.dequeueRequests();
        }
    };
    MPDProtocol.prototype.dequeueRequests = function () {
        var _this = this;
        if (this.queuedRequests.length > 0) {
            this.runningRequests = this.queuedRequests;
            this.queuedRequests = [];
            this.idle = false;
        }
        else {
            this.runningRequests = [{ cmd: 'idle', resolve: function (lines) { return _this.idleCallback(lines); }, reject: function () { } }];
            this.idle = true;
        }
        var commandString;
        if (this.runningRequests.length == 1) {
            commandString = this.runningRequests[0].cmd + '\n';
        }
        else {
            commandString = 'command_list_ok_begin\n';
            this.runningRequests.forEach(function (command) {
                commandString += command.cmd + '\n';
            });
            commandString += 'command_list_end\n';
        }
        this._connection.send(commandString);
    };
    MPDProtocol.prototype.initialCallback = function (msg) {
        var match = /^OK MPD ([0-9]+)\.([0-9]+)\.([0-9]+)/.exec(msg);
        this.mpdVersion = [Number(match[1]), Number(match[2]), Number(match[3])];
        this.emit('ready');
    };
    MPDProtocol.prototype.idleCallback = function (lines) {
        var _this = this;
        this.idle = false;
        var subsystems = lines.map(function (changed) { return changed.substring(9); });
        this.emit('changed', subsystems);
        subsystems.forEach(function (subsystem) { return _this.emit("changed-" + subsystem); });
    };
    MPDProtocol.failureRegExp = /ACK \[([0-9]+)@[0-9]+\] \{[^\}]*\} (.*)/;
    return MPDProtocol;
}(eventemitter3_1.EventEmitter));
exports.MPDProtocol = MPDProtocol;
//# sourceMappingURL=protocol.js.map
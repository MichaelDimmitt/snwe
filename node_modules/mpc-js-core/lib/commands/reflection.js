"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var decoder_1 = require("../objects/decoder");
var util_1 = require("../util");
var ReflectionCommands = (function () {
    function ReflectionCommands(protocol) {
        this.protocol = protocol;
    }
    /**
     * Dumps configuration values that may be interesting for the client.
     * This command is only permitted to "local" clients (connected via UNIX domain socket).
     * The following response attributes are available:
     * * `music_directory`: The absolute path of the music directory.
     */
    ReflectionCommands.prototype.config = function () {
        var _this = this;
        return this.protocol.sendCommand('config').then(function (lines) { return _this.protocol.parse(lines, [], function (valueMap) { return valueMap; })[0]; });
    };
    /**
     * Shows which commands the current user has access to.
     */
    ReflectionCommands.prototype.commands = function () {
        return this.protocol.sendCommand('commands').then(function (lines) { return lines.map(function (line) { return line.substring(9); }); });
    };
    /**
     * Shows which commands the current user has access to.
     */
    ReflectionCommands.prototype.notCommands = function () {
        return this.protocol.sendCommand('notcommands').then(function (lines) { return lines.map(function (line) { return line.substring(9); }); });
    };
    /**
     * Shows a list of available song metadata.
     */
    ReflectionCommands.prototype.tagTypes = function () {
        return this.protocol.sendCommand('tagtypes').then(function (lines) { return lines.map(function (line) { return line.substring(9); }); });
    };
    /**
     * Gets a list of available URL handlers.
     */
    ReflectionCommands.prototype.urlHandlers = function () {
        return this.protocol.sendCommand('urlhandlers').then(function (lines) { return lines.map(function (line) { return line.substring(9); }); });
    };
    /**
     * Returns a list of decoder plugins with their supported suffixes and MIME types.
     */
    ReflectionCommands.prototype.decoders = function () {
        return this.protocol.sendCommand('decoders').then(function (lines) {
            var decoders = [];
            var currentDecoder;
            lines.forEach(function (line) {
                if (util_1.stringStartsWith(line, 'plugin')) {
                    if (currentDecoder) {
                        decoders.push(currentDecoder);
                    }
                    currentDecoder = new decoder_1.Decoder(line.substring(8));
                }
                else if (util_1.stringStartsWith(line, 'suffix')) {
                    currentDecoder.suffixes.push(line.substr(8));
                }
                else if (util_1.stringStartsWith(line, 'mime_type')) {
                    currentDecoder.mimeTypes.push(line.substr(11));
                }
            });
            return decoders;
        });
    };
    return ReflectionCommands;
}());
exports.ReflectionCommands = ReflectionCommands;
//# sourceMappingURL=reflection.js.map
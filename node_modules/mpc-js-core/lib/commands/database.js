"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var database_1 = require("../objects/database");
var DatabaseCommands = (function () {
    function DatabaseCommands(protocol) {
        this.protocol = protocol;
    }
    /**
     * Counts the number of songs and their total playtime in the database that match exactly.
     * Note that tags are case sensitive and that the MPD documentation incorrectly lists all
     * tags as lower-case. Use `mpc.reflection.tagTypes()` to get the correct list of tags
     * supported by MPD.
     */
    DatabaseCommands.prototype.count = function (tagsAndNeedles) {
        var _this = this;
        var cmd = 'count';
        tagsAndNeedles.forEach(function (tagAndNeedle) {
            cmd += " " + tagAndNeedle[0] + " \"" + tagAndNeedle[1] + "\"";
        });
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, [], function (valueMap) { return new database_1.SongCount(valueMap); })[0]; });
    };
    /**
     * Counts the number of songs and their total playtime in the database that match exactly.
     * The results are grouped by tag `groupingTag` (e.g. 'Artist', 'Album', 'Date', 'Genre')
     * Note that tags are case sensitive and that the MPD documentation incorrectly lists all
     * tags as lower-case. Use `mpc.reflection.tagTypes()` to get the correct list of tags
     * supported by MPD.
     */
    DatabaseCommands.prototype.countGrouped = function (tagsAndNeedles, groupingTag) {
        var _this = this;
        var cmd = 'count';
        tagsAndNeedles.forEach(function (tagAndNeedle) {
            cmd += " " + tagAndNeedle[0] + " \"" + tagAndNeedle[1] + "\"";
        });
        cmd += " group " + groupingTag;
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, [groupingTag], function (valueMap) { return new database_1.GroupedSongCount(valueMap, groupingTag); }); });
    };
    /**
     * Finds songs in the database that match exactly. `type` can be any tag supported by MPD,
     * or one of the special parameters:
     * * 'any' checks all tag values
     * * 'file' checks the full path (relative to the music directory)
     * * 'base' restricts the search to songs in the given directory (also relative to the music directory)
     * * 'modified-since' compares the file's time stamp with the given value (ISO 8601 or UNIX time stamp)
     * `start` and `end` can be used to query only a portion of the real response.
     * Note that tags are case sensitive and that the MPD documentation incorrectly lists all
     * tags as lower-case. Use `mpc.reflection.tagTypes()` to get the correct list of tags
     * supported by MPD.
     */
    DatabaseCommands.prototype.find = function (typesAndNeedles, start, end) {
        var _this = this;
        var cmd = 'find';
        typesAndNeedles.forEach(function (typeAndNeedle) {
            cmd += " " + typeAndNeedle[0] + " \"" + typeAndNeedle[1] + "\"";
        });
        if ((typeof start === 'number') && (typeof end === 'number')) {
            cmd += " window " + start + ":" + end;
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file'], function (valueMap) { return database_1.DirectoryEntry.fromValueMap(valueMap, true); }); });
    };
    /**
     * Finds songs in the database that match exactly and adds them to the current playlist.
     * Parameters have the same meaning as for `find()`.
     */
    DatabaseCommands.prototype.findAdd = function (typesAndNeedles) {
        var cmd = 'findadd';
        typesAndNeedles.forEach(function (typeAndNeedle) {
            cmd += " " + typeAndNeedle[0] + " \"" + typeAndNeedle[1] + "\"";
        });
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Searches for any song that matches. Parameters have the same meaning as for `find()`,
     * except that the search is a case insensitive substring search.
     */
    DatabaseCommands.prototype.search = function (typesAndNeedles, start, end) {
        var _this = this;
        var cmd = 'search';
        typesAndNeedles.forEach(function (typeAndNeedle) {
            cmd += " " + typeAndNeedle[0] + " \"" + typeAndNeedle[1] + "\"";
        });
        if ((typeof start === 'number') && (typeof end === 'number')) {
            cmd += " window " + start + ":" + end;
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file'], function (valueMap) { return database_1.DirectoryEntry.fromValueMap(valueMap, true); }); });
    };
    /**
     * Searches for any song that matches and adds them to the current playlist.
     * Parameters have the same meaning as for `find()`, except that the search is a
     * case insensitive substring search.
     */
    DatabaseCommands.prototype.searchAdd = function (typesAndNeedles) {
        var cmd = 'searchadd';
        typesAndNeedles.forEach(function (typeAndNeedle) {
            cmd += " " + typeAndNeedle[0] + " \"" + typeAndNeedle[1] + "\"";
        });
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Searches for any song that matches and adds them to the playlist named `name`.
     * If a playlist by that name doesn't exist it is created.
     * Parameters have the same meaning as for `find()`, except that the search is a
     * case insensitive substring search.
     */
    DatabaseCommands.prototype.searchAddPlaylist = function (name, typesAndNeedles) {
        var cmd = "searchaddpl " + name;
        typesAndNeedles.forEach(function (typeAndNeedle) {
            cmd += " " + typeAndNeedle[0] + " \"" + typeAndNeedle[1] + "\"";
        });
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Lists the contents of the directory `uri`, including files are not recognized by MPD.
     * `uri` can be a path relative to the music directory or an URI understood by one of the
     * storage plugins. For example, "smb://SERVER" returns a list of all shares on the given
     * SMB/CIFS server; "nfs://servername/path" obtains a directory listing from the NFS server.
     */
    DatabaseCommands.prototype.listFiles = function (uri) {
        var _this = this;
        var cmd = 'listfiles';
        if (uri) {
            cmd += " \"" + uri + "\"";
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file', 'directory'], function (valueMap) { return database_1.DirectoryEntry.fromValueMap(valueMap, false); }); });
    };
    /**
     * Lists the contents of the directory `uri`. When listing the root directory, this currently
     * returns the list of stored playlists. This behavior is deprecated; use `listPlaylists()`
     * instead. This command may be used to list metadata of remote files (e.g. `uri` beginning
     * with "http://" or "smb://"). Clients that are connected via UNIX domain socket may use this
     * command to read the tags of an arbitrary local file (`uri` is an absolute path).
     */
    DatabaseCommands.prototype.listInfo = function (uri) {
        var _this = this;
        var cmd = 'lsinfo';
        if (uri) {
            cmd += " \"" + uri + "\"";
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file', 'playlist', 'directory'], function (valueMap) { return database_1.DirectoryEntry.fromValueMap(valueMap, true); }); });
    };
    /**
     * Lists all songs and directories in `uri` recursively. Do not use this command to manage a
     * client-side copy of MPD's database. That is fragile and adds huge overhead.
     * It will break with large databases. Instead, query MPD whenever you need something.
     */
    DatabaseCommands.prototype.listAll = function (uri) {
        var cmd = 'listall';
        if (uri) {
            cmd += " \"" + uri + "\"";
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return lines.map(function (line) {
            return line.substring(line.indexOf(':') + 2);
        }); });
    };
    /**
     * Same as `listAll()`, except it also returns metadata info. Do not use this command to
     * manage a client-side copy of MPD's database. That is fragile and adds huge overhead.
     * It will break with large databases. Instead, query MPD whenever you need something.
     */
    DatabaseCommands.prototype.listAllInfo = function (uri) {
        var _this = this;
        var cmd = 'listallinfo';
        if (uri) {
            cmd += " \"" + uri + "\"";
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file', 'playlist', 'directory'], function (valueMap) { return database_1.DirectoryEntry.fromValueMap(valueMap, true); }); });
    };
    /**
     * Lists unique tags values of the specified type. `type` can be any tag supported by MPD
     * or 'file'. `typesAndNeedles` specifies a filter like the one in `find()`.
     * `groupingTags` may be used to group the results by one or more tags.
     * Note that tags are case sensitive and that the MPD documentation incorrectly lists all
     * tags as lower-case. Use `mpc.reflection.tagTypes()` to get the correct list of tags
     * supported by MPD.
     */
    DatabaseCommands.prototype.list = function (type, typesAndNeedles, groupingTags) {
        var _this = this;
        if (typesAndNeedles === void 0) { typesAndNeedles = []; }
        if (groupingTags === void 0) { groupingTags = []; }
        var cmd = "list " + type;
        typesAndNeedles.forEach(function (typeAndNeedle) {
            cmd += " " + typeAndNeedle[0] + " \"" + typeAndNeedle[1] + "\"";
        });
        groupingTags.forEach(function (tag) {
            cmd += " group " + tag;
        });
        return this.protocol.sendCommand(cmd).then(function (lines) {
            var tagsGroupedByString = new Map();
            _this.protocol.parse(lines, [type], function (map) {
                var group = [];
                groupingTags.forEach(function (groupingTag) { return group.push(map.get(groupingTag)); });
                var groupString = JSON.stringify(group);
                if (!tagsGroupedByString.has(groupString)) {
                    tagsGroupedByString.set(groupString, []);
                }
                tagsGroupedByString.get(groupString).push(map.get(type));
            });
            var groupedTags = new Map();
            tagsGroupedByString.forEach(function (tags, groupString) {
                var group = JSON.parse(groupString);
                groupedTags.set(group, tags);
            });
            return groupedTags;
        });
    };
    /**
     * Read "comments" (i.e. key-value pairs) from the file specified by `uri`. This `uri` can be
     * a path relative to the music directory or an absolute path. This command may be used to list
     * metadata of remote files (e.g. `uri` beginning with "http://" or "smb://").
     * Comments with suspicious characters (e.g. newlines) are ignored silently.
     * The meaning of these depends on the codec, and not all decoder plugins support it.
     * For example, on Ogg files, this lists the Vorbis comments.
     */
    DatabaseCommands.prototype.readComments = function (uri) {
        var _this = this;
        var cmd = "readcomments \"" + uri + "\"";
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, [], function (map) { return map; })[0]; });
    };
    /**
     * Updates the music database: find new files, remove deleted files, update modified files.
     * `uri` is a particular directory or song/file to update. If you do not specify it, everything
     * is updated. Returns a positive number identifying the update job. You can read the current
     * job id in the status response.
     */
    DatabaseCommands.prototype.update = function (uri) {
        var cmd = 'update';
        if (uri) {
            cmd += " \"" + uri + "\"";
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return Number(lines[0].substring(13)); });
    };
    /**
     * Same as `update()`, but also rescans unmodified files.
     */
    DatabaseCommands.prototype.rescan = function (uri) {
        var cmd = 'rescan';
        if (uri) {
            cmd += " \"" + uri + "\"";
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return Number(lines[0].substring(13)); });
    };
    return DatabaseCommands;
}());
exports.DatabaseCommands = DatabaseCommands;
//# sourceMappingURL=database.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var playlists_1 = require("../objects/playlists");
var CurrentPlaylistCommands = (function () {
    function CurrentPlaylistCommands(protocol) {
        this.protocol = protocol;
    }
    /**
     * Adds the file or directory `uri` to the playlist (directories add recursively).
     */
    CurrentPlaylistCommands.prototype.add = function (uri) {
        var cmd = "add \"" + uri + "\"";
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Adds a song to the playlist (non-recursive) and returns the song id.
     * `uri` is always a single file or URL.
     */
    CurrentPlaylistCommands.prototype.addId = function (uri, position) {
        var cmd = "addid \"" + uri + "\"";
        if (typeof position === 'number') {
            cmd += " " + position;
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return Number(lines[0].substring(4)); });
    };
    /**
     * Clears the current playlist.
     */
    CurrentPlaylistCommands.prototype.clear = function () {
        return this.protocol.sendCommand('clear').then(function () { });
    };
    /**
     * Deletes a song from the playlist.
     */
    CurrentPlaylistCommands.prototype.delete = function (position) {
        var cmd = "delete " + position;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Deletes a song range from the playlist.
     */
    CurrentPlaylistCommands.prototype.deleteRange = function (start, end) {
        var cmd = "delete " + start + ":";
        if (typeof end === 'number') {
            cmd += end;
        }
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Deletes the song with the given songid from the playlist.
     */
    CurrentPlaylistCommands.prototype.deleteId = function (songId) {
        var cmd = "deleteid " + songId;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Moves the song at `from` to `to` in the playlist.
     */
    CurrentPlaylistCommands.prototype.move = function (from, to) {
        var cmd = "move " + from + " " + to;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Moves the range of songs from `start` to `end` to `to` in the playlist.
     */
    CurrentPlaylistCommands.prototype.moveRange = function (start, end, to) {
        var cmd = "move " + start + ":" + end + " " + to;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Moves the song with the given songid to `to` the playlist.
     * If `to` is negative, it is relative to the current song in the playlist (if there is one).
     */
    CurrentPlaylistCommands.prototype.moveId = function (songId, to) {
        var cmd = "moveid " + songId + " " + to;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Finds songs in the current playlist with strict matching.
     */
    CurrentPlaylistCommands.prototype.playlistFind = function (tag, needle) {
        var _this = this;
        var cmd = "playlistfind \"" + tag + "\" \"" + needle + "\"";
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file'], function (valueMap) { return new playlists_1.PlaylistItem(valueMap); }); });
    };
    /**
     * Searches case-insensitively for partial matches in the current playlist.
     */
    CurrentPlaylistCommands.prototype.playlistSearch = function (tag, needle) {
        var _this = this;
        var cmd = "playlistsearch \"" + tag + "\" \"" + needle + "\"";
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file'], function (valueMap) { return new playlists_1.PlaylistItem(valueMap); }); });
    };
    /**
     * Gets info for the song with the specified songid in the playlist.
     */
    CurrentPlaylistCommands.prototype.playlistId = function (songId) {
        var _this = this;
        var cmd = "playlistid " + songId;
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, [], function (valueMap) { return new playlists_1.PlaylistItem(valueMap); })[0]; });
    };
    /**
     * Gets info for all songs or a single song in the playlist.
     */
    CurrentPlaylistCommands.prototype.playlistInfo = function (position) {
        var _this = this;
        var cmd = 'playlistinfo';
        if (typeof position === 'number') {
            cmd += " " + position;
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file'], function (valueMap) { return new playlists_1.PlaylistItem(valueMap); }); });
    };
    /**
     * Gets info for a range of songs in the playlist.
     */
    CurrentPlaylistCommands.prototype.playlistRangeInfo = function (start, end) {
        var _this = this;
        var cmd = "playlistinfo " + start + ":";
        if (typeof end === 'number') {
            cmd += "" + end;
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file'], function (valueMap) { return new playlists_1.PlaylistItem(valueMap); }); });
    };
    /**
     * Displays changed songs currently in the playlist since `version`. Start and end positions
     * may be given to limit the output to changes in the given range. To detect songs that were
     * deleted at the end of the playlist, use playlistlength returned by status command.
     */
    CurrentPlaylistCommands.prototype.playlistChanges = function (version, start, end) {
        var _this = this;
        var cmd = "plchanges " + version;
        if (typeof start === 'number') {
            cmd += " " + start + ":";
            if (typeof end === 'number') {
                cmd += end;
            }
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['file'], function (valueMap) { return new playlists_1.PlaylistItem(valueMap); }); });
    };
    /**
     * Displays changed songs currently in the playlist since `version`. This function only returns
     * the position and the id of the changed song, not the complete metadata. This is more
     * bandwidth efficient. To detect songs that were deleted at the end of the playlist, use
     * playlistlength returned by status command.
     */
    CurrentPlaylistCommands.prototype.playlistChangesPosId = function (version, start, end) {
        var _this = this;
        var cmd = "plchangesposid " + version;
        if (typeof start === 'number') {
            cmd += " " + start + ":";
            if (typeof end === 'number') {
                cmd += end;
            }
        }
        return this.protocol.sendCommand(cmd).then(function (lines) { return _this.protocol.parse(lines, ['cpos'], function (valueMap) { return new playlists_1.SongIdAndPosition(valueMap); }); });
    };
    /**
     * Set the priority of the specified songs. A higher priority means that it will be played
     * first when "random" mode is enabled.
     * A priority is an integer between 0 and 255. The default priority of new songs is 0.
     */
    CurrentPlaylistCommands.prototype.prio = function (priority, start, end) {
        var cmd = "prio " + priority + " " + start + ":" + end;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Same as prio, but address the songs with their songid.
     */
    CurrentPlaylistCommands.prototype.prioId = function (priority, songId) {
        var cmd = "prioid " + priority + " " + songId;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Specifies the portion of the song that shall be played. `start` and `end` are offsets
     * in seconds (fractional seconds allowed); both are optional. Omitting both means "remove the
     * range, play everything". A song that is currently playing cannot be manipulated this way.
     */
    CurrentPlaylistCommands.prototype.rangeId = function (songId, start, end) {
        var cmd = "rangeid " + songId + " ";
        if (typeof start === 'number') {
            cmd += start;
        }
        cmd += ':';
        if (typeof end === 'number') {
            cmd += end;
        }
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Shuffles the current playlist. `start` and `end` is optional and specifies a range of songs.
     */
    CurrentPlaylistCommands.prototype.shuffle = function (start, end) {
        var cmd = 'shuffle';
        if (typeof start === 'number') {
            cmd += " " + start + ":";
            if (typeof end === 'number') {
                cmd += end;
            }
        }
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Swaps the positions of `song1` and `song2`.
     */
    CurrentPlaylistCommands.prototype.swap = function (song1, song2) {
        var cmd = "swap " + song1 + " " + song2;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Swaps the positions of `song1` and `song2` (both songids).
     */
    CurrentPlaylistCommands.prototype.swapId = function (song1, song2) {
        var cmd = "swapid " + song1 + " " + song2;
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Adds a tag to the specified song. Editing song tags is only possible for remote songs.
     * This change is volatile: it may be overwritten by tags received from the server, and the
     * data is gone when the song gets removed from the queue.
     */
    CurrentPlaylistCommands.prototype.addTagId = function (songId, tag, value) {
        var cmd = "addtagid " + songId + " \"" + tag + "\" \"" + value + "\"";
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    /**
     * Removes tags from the specified song. If `tag` is not specified, then all tag values will be
     * removed. Editing song tags is only possible for remote songs.
     */
    CurrentPlaylistCommands.prototype.clearTagId = function (songId, tag) {
        var cmd = "cleartagid " + songId;
        if (tag) {
            cmd += " \"" + tag + "\"";
        }
        return this.protocol.sendCommand(cmd).then(function () { });
    };
    return CurrentPlaylistCommands;
}());
exports.CurrentPlaylistCommands = CurrentPlaylistCommands;
//# sourceMappingURL=currentPlaylist.js.map